# üöÄ GraphQL API Pr≈Øvodce - Lootea B2B Backend

Kompletn√≠ referenƒçn√≠ pr≈Øvodce jak funguje GraphQL API v na≈°em Rails projektu.

---

## üìã Obsah
- [Jak GraphQL funguje](#-jak-graphql-funguje)
- [Architektura syst√©mu](#-architektura-syst√©mu)
- [Autentizace flow](#-autentizace-flow)
- [Typy dat](#-typy-dat)
- [Queries - ƒçten√≠ dat](#-queries---ƒçten√≠-dat)
- [Mutations - z√°pis dat](#-mutations---z√°pis-dat)
- [Praktick√© p≈ô√≠klady](#-praktick√©-p≈ô√≠klady)
- [Testov√°n√≠](#-testov√°n√≠)
- [Chybov√© stavy](#-chybov√©-stavy)
- [Best practices](#-best-practices)

---

## üîÑ Jak GraphQL funguje

### Z√°kladn√≠ princip
GraphQL je **query language** - frontend si "objedn√°" p≈ôesnƒõ ta data, kter√° pot≈ôebuje v jednom requestu.

```mermaid
sequenceDiagram
    participant F as Frontend (Next.js)
    participant R as Rails GraphQL API
    participant D as PostgreSQL DB

    F->>R: POST /graphql + query
    Note over F,R: Jeden endpoint pro v≈°e

    R->>R: Parsov√°n√≠ + validace query
    R->>D: SQL dotazy dle query
    D-->>R: Data z datab√°ze
    R->>R: Sestaven√≠ odpovƒõdi dle query
    R-->>F: JSON s p≈ôesnƒõ po≈æadovan√Ωmi daty

    Note over F,R: Frontend dostal jen to, co chtƒõl
```

### Porovn√°n√≠ s REST API

| **REST API** | **GraphQL API** |
|--------------|-----------------|
| `GET /products` | `query { products { name price } }` |
| `GET /users/1` | `query { user(id: 1) { email } }` |
| `POST /orders` | `mutation { createOrder(...) { id } }` |
| **V√≠ce request≈Ø** | **Jeden request** |
| **Over-fetching** | **P≈ôesn√° data** |
| **V√≠ce endpoint≈Ø** | **Jeden endpoint** |

---

## üèó Architektura syst√©mu

### Celkov√Ω p≈ôehled
```mermaid
graph TD
    A[Frontend Next.js] --> B[HTTP POST /graphql]
    B --> C[GraphqlController]
    C --> D[JWT Autentizace]
    D --> E[GraphQL Schema]
    E --> F[Resolvers - na≈°e metody]
    F --> G[ActiveRecord Models]
    G --> H[PostgreSQL Database]
    H --> I[JSON Response]
    I --> A

    style A fill:#e1f5fe,color:#000
    style C fill:#f3e5f5,color:#000
    style E fill:#e8f5e8,color:#000
    style H fill:#fff3e0,color:#000
```

### Struktura soubor≈Ø
```
app/graphql/
‚îú‚îÄ‚îÄ lootea_b2b_backend_schema.rb    # Hlavn√≠ schema
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ query_type.rb               # Root queries
‚îÇ   ‚îú‚îÄ‚îÄ mutation_type.rb            # Root mutations
‚îÇ   ‚îú‚îÄ‚îÄ product_type.rb             # Product GraphQL typ
‚îÇ   ‚îú‚îÄ‚îÄ user_type.rb                # User GraphQL typ
‚îÇ   ‚îú‚îÄ‚îÄ order_type.rb               # Order GraphQL typ
‚îÇ   ‚îî‚îÄ‚îÄ order_item_type.rb          # OrderItem GraphQL typ
‚îî‚îÄ‚îÄ mutations/
    ‚îú‚îÄ‚îÄ login_user.rb               # P≈ôihl√°≈°en√≠
    ‚îú‚îÄ‚îÄ register_user.rb            # Registrace
    ‚îî‚îÄ‚îÄ create_order.rb             # Vytvo≈ôen√≠ objedn√°vky
```

---

## üîê Autentizace flow

### 1. Registrace/P≈ôihl√°≈°en√≠
```mermaid
sequenceDiagram
    participant F as Frontend
    participant G as GraphQL API
    participant D as Database
    participant J as JWT Service

    F->>G: mutation registerUser/loginUser
    G->>D: Najdi/vytvo≈ô user v DB
    D-->>G: User object
    G->>J: Vygeneruj JWT token
    J-->>G: JWT token
    G-->>F: { user, token, errors }

    Note over F: Ulo≈æ√≠ token do localStorage
```

### 2. Autentizovan√© requesty
```mermaid
sequenceDiagram
    participant F as Frontend
    participant G as GraphqlController
    participant J as JWT Decoder
    participant D as Database

    F->>G: POST /graphql + Authorization header
    Note over F,G: Authorization: Bearer <token>

    G->>J: Dek√≥duj JWT token
    J-->>G: User ID z tokenu
    G->>D: User.find(id)
    D-->>G: current_user object
    G->>G: P≈ôid√° current_user do context

    Note over G: Resolver m√° p≈ô√≠stup k current_user
```

### JWT Token struktur
```ruby
# Payload v JWT tokenu
{
  "sub": 123,           # User ID
  "iat": 1640995200     # Issued at timestamp
}

# V Rails controlleru
def current_user
  token = request.headers['Authorization']&.split(' ')&.last
  decoded = JWT.decode(token, secret_key)
  User.find(decoded.first['sub'])
end
```

---

## üìä Typy dat

### ProductType
```ruby
field :id, ID, null: false
field :name, String, null: false
field :price_cents, Integer, null: false      # Pro p≈ôesnost
field :price_decimal, Float, null: false      # Pro frontend UX
field :currency, String, null: false
```

### UserType
```ruby
field :id, ID, null: false
field :email, String, null: false
field :role, String, null: false              # "customer" | "admin"
field :company_name, String, null: true
field :orders, [OrderType], null: false       # Association
```

### OrderType
```ruby
field :id, ID, null: false
field :total_cents, Integer, null: false
field :total_decimal, Float, null: false      # Helper field
field :status, String, null: false            # "pending" | "paid" | ...
field :is_pending, Boolean, null: false       # Computed field
field :items_count, Integer, null: false      # Computed field
field :order_items, [OrderItemType], null: false
```

---

## üîç Queries - ƒçten√≠ dat

### Seznam produkt≈Ø
```graphql
query GetProducts {
  products {
    id
    name
    description
    priceDecimal
    currency
    available
  }
}
```

**Rails resolver:**
```ruby
def products
  Product.available.order(:name)
end
```

**SQL dotaz:**
```sql
SELECT * FROM products WHERE available = true ORDER BY name;
```

### Aktu√°ln√≠ u≈æivatel
```graphql
query CurrentUser {
  currentUser {
    id
    email
    role
    companyName
    orders {
      id
      totalDecimal
      status
    }
  }
}
```

**Rails resolver:**
```ruby
def current_user
  context[:current_user]  # Z JWT autentizace
end
```

### Nested data v jednom requestu
```graphql
query MyOrdersWithProducts {
  myOrders {
    id
    totalDecimal
    createdAt
    orderItems {
      quantity
      unitPriceDecimal
      product {
        name
        description
      }
    }
  }
}
```

**V√Ωsledek:**
```json
{
  "data": {
    "myOrders": [
      {
        "id": "1",
        "totalDecimal": 598.0,
        "orderItems": [
          {
            "quantity": 2,
            "unitPriceDecimal": 299.0,
            "product": {
              "name": "Lootea Premium"
            }
          }
        ]
      }
    ]
  }
}
```

---

## ‚ö° Mutations - z√°pis dat

### P≈ôihl√°≈°en√≠
```graphql
mutation LoginUser {
  loginUser(
    email: "tomas@example.com"
    password: "heslo123"
  ) {
    user {
      id
      email
      role
    }
    token
    errors
  }
}
```

**Rails resolver flow:**
```mermaid
graph TD
    A[loginUser mutation] --> B[User.find_by email]
    B --> C{valid_password?}
    C -->|Ano| D[generate_jwt_token]
    C -->|Ne| E[errors: neplatn√© √∫daje]
    D --> F[return user + token]
    E --> G[return nil + errors]
```

### Vytvo≈ôen√≠ objedn√°vky
```graphql
mutation CreateOrder {
  createOrder(
    items: [
      { productId: "1", quantity: 2 },
      { productId: "3", quantity: 1 }
    ]
    currency: "CZK"
  ) {
    order {
      id
      totalDecimal
      orderItems {
        quantity
        totalDecimal
        product {
          name
        }
      }
    }
    errors
  }
}
```

**Rails resolver flow:**
```mermaid
graph TD
    A[createOrder mutation] --> B{current_user?}
    B -->|Ne| C[return error]
    B -->|Ano| D[validace items]
    D --> E[Product.where id in items]
    E --> F[kalkulace total_cents]
    F --> G[BEGIN TRANSACTION]
    G --> H[Order.create!]
    H --> I[OrderItem.create! pro ka≈æd√Ω item]
    I --> J[COMMIT]
    J --> K[return order]

    G --> L{Chyba?}
    L -->|Ano| M[ROLLBACK + return errors]
```

---

## üíª Praktick√© p≈ô√≠klady

### Frontend Next.js - Apollo Client
```javascript
// Query
const GET_PRODUCTS = gql`
  query GetProducts {
    products {
      id
      name
      priceDecimal
      currency
    }
  }
`;

const { data, loading } = useQuery(GET_PRODUCTS);

// Mutation s autentizac√≠
const LOGIN_USER = gql`
  mutation LoginUser($email: String!, $password: String!) {
    loginUser(email: $email, password: $password) {
      user { id email }
      token
      errors
    }
  }
`;

const [loginUser] = useMutation(LOGIN_USER, {
  context: {
    headers: {
      authorization: token ? `Bearer ${token}` : "",
    }
  }
});
```

### cURL p≈ô√≠klady
```bash
# Query bez autentizace
curl -X POST http://localhost:3000/graphql \
  -H "Content-Type: application/json" \
  -d '{"query": "{ products { id name priceDecimal } }"}'

# Mutation s autentizac√≠
curl -X POST http://localhost:3000/graphql \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -d '{"query": "mutation { createOrder(items: [{productId: \"1\", quantity: 2}]) { order { id } errors } }"}'
```

---

## üß™ Testov√°n√≠

### 1. GraphiQL Interface
```
http://localhost:3000/graphiql
```

**Testovac√≠ sekvence:**
1. Registrace u≈æivatele
2. Kop√≠rov√°n√≠ JWT tokenu
3. Nastaven√≠ Authorization header
4. Testov√°n√≠ protected queries

### 2. Rails konzole
```ruby
# Vytvo≈ôen√≠ testovac√≠ch dat
user = User.create!(email: "test@example.com", password: "password123")
product = Product.create!(name: "Test Tea", price_cents: 29900, currency: "CZK")

# Testov√°n√≠ GraphQL
result = LooteaB2bBackendSchema.execute(
  "{ products { id name priceDecimal } }"
)
puts result.to_json
```

### 3. Postman collection
```json
{
  "info": { "name": "Lootea GraphQL API" },
  "item": [
    {
      "name": "Products Query",
      "request": {
        "method": "POST",
        "url": "{{base_url}}/graphql",
        "header": [{"key": "Content-Type", "value": "application/json"}],
        "body": {
          "raw": "{\"query\": \"{ products { id name priceDecimal } }\"}"
        }
      }
    }
  ]
}
```

---

## ‚ùå Chybov√© stavy

### Validation errors
```json
{
  "data": {
    "createOrder": {
      "order": null,
      "errors": [
        "Mus√≠te b√Ωt p≈ôihl√°≈°eni pro vytvo≈ôen√≠ objedn√°vky"
      ]
    }
  }
}
```

### GraphQL syntax errors
```json
{
  "errors": [
    {
      "message": "Field 'invalidField' doesn't exist on type 'ProductType'",
      "locations": [{"line": 2, "column": 5}]
    }
  ]
}
```

### JWT errors
```json
{
  "data": {
    "currentUser": null
  }
}
```

---

## üéØ Best Practices

### 1. **Ceny - v≈ædy v centech**
```ruby
# ‚úÖ Spr√°vnƒõ
field :price_cents, Integer, null: false
field :price_decimal, Float, null: false

# ‚ùå ≈†patnƒõ
field :price, Float, null: false  # Float probl√©my!
```

### 2. **Helper fields pro UX**
```ruby
# Pro frontend pohodl√≠
field :is_pending, Boolean, null: false
def is_pending
  object.pending?
end

field :items_count, Integer, null: false
def items_count
  object.order_items.sum(:quantity)
end
```

### 3. **Error handling**
```ruby
def resolve(...)
  {
    order: order,
    errors: order.errors.full_messages  # Strukturovan√© chyby
  }
rescue => e
  {
    order: nil,
    errors: [e.message]
  }
end
```

### 4. **Transaction safety**
```ruby
ActiveRecord::Base.transaction do
  order = Order.create!(...)
  items.each { |item| OrderItem.create!(...) }
  { order: order, errors: [] }
rescue => e
  { order: nil, errors: [e.message] }
end
```

### 5. **Security considerations**
```ruby
# Jen bezpeƒçn√© fieldy v UserType
field :email, String, null: false
# field :encrypted_password  # ‚ùå NIKDY!

# Kontrola autentizace
def my_orders
  return [] unless context[:current_user]
  context[:current_user].orders
end
```

---

## üîó U≈æiteƒçn√© odkazy

- **GraphiQL development:** `http://localhost:3000/graphiql`
- **GraphQL schema:** `app/graphql/lootea_b2b_backend_schema.rb`
- **Rails GraphQL gem:** https://graphql-ruby.org/
- **Apollo Client (frontend):** https://www.apollographql.com/docs/react/

---

## üéì Shrnut√≠ v√Ωhod

### **Pro Backend v√Ωvoj√°≈ôe:**
- ‚úÖ Jeden endpoint m√≠sto 20 REST routes
- ‚úÖ Type safety a validace zadarmo
- ‚úÖ Automatick√° dokumentace
- ‚úÖ Flexibiln√≠ data fetching

### **Pro Frontend v√Ωvoj√°≈ôe:**
- ‚úÖ P≈ôesnƒõ ta data, kter√° pot≈ôebuje
- ‚úÖ Nested data v jednom requestu
- ‚úÖ Intellisense a autocomplete
- ‚úÖ Cached responses (Apollo Client)

### **Pro t√Ωm:**
- ‚úÖ Schema jako smlouva mezi FE a BE
- ‚úÖ GraphiQL jako living documentation
- ‚úÖ M√©nƒõ komunikace ohlednƒõ API zmƒõn
- ‚úÖ Rychlej≈°√≠ v√Ωvoj nov√Ωch features

---

**üöÄ Teƒè m√°≈° kompletn√≠ p≈ôehled o tom, jak na≈°e GraphQL API funguje!**